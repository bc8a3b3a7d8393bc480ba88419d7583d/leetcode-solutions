[{"questionId": "111", "titleSlug": "minimum-depth-of-binary-tree", "content": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 2. Example 2: Input: root = [2,null,3,null,4,null,5,null,6] Output: 5. Constraints: The number of nodes in the tree is in the range [0, 10^5]. -1000 <= Node.val <= 1000.", "typed_code": "\n        var minDepth = function(root) {\n            if (!root) return 0;\n            let left = minDepth(root.left);\n            let right = minDepth(root.right);\n            return (!root.left || !root.right) ? left + right + 1 : Math.min(left, right) + 1;\n        };\n        "}, {"questionId": "112", "titleSlug": "path-sum", "content": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true. Example 2: Input: root = [1,2,3], targetSum = 5 Output: false. Example 3: Input: root = [], targetSum = 0 Output: false. Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 <= Node.val <= 1000. -1000 <= targetSum <= 1000.", "typed_code": "\n        var hasPathSum = function(root, targetSum) {\n            if (!root) return false;\n            if (!root.left && !root.right) return targetSum === root.val;\n            return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n        };\n        "}, {"questionId": "113", "titleSlug": "path-sum-ii", "content": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]]. Example 2: Input: root = [1,2,3], targetSum = 5 Output: []. Example 3: Input: root = [1,2], targetSum = 0 Output: []. Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 <= Node.val <= 1000. -1000 <= targetSum <= 1000.", "typed_code": "\n        var pathSum = function(root, targetSum) {\n            const result = [];\n            const findPaths = (node, sum, path) => {\n                if (!node) return;\n                path.push(node.val);\n                if (!node.left && !node.right && sum === node.val) {\n                    result.push([...path]);\n                }\n                findPaths(node.left, sum - node.val, path);\n                findPaths(node.right, sum - node.val, path);\n                path.pop();\n            };\n            findPaths(root, targetSum, []);\n            return result;\n        };\n        "}, {"questionId": "114", "titleSlug": "flatten-binary-tree-to-linked-list", "content": "Given the root of a binary tree, flatten the tree into a 'linked list': The 'linked list' should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The 'linked list' should be in the same order as a pre-order traversal of the binary tree. Example 1: Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6]. Example 2: Input: root = [] Output: []. Example 3: Input: root = [0] Output: [0]. Constraints: The number of nodes in the tree is in the range [0, 2000]. -100 <= Node.val <= 100.", "typed_code": "\n        var flatten = function(root) {\n            let prev = null;\n            const flattenTree = (node) => {\n                if (!node) return;\n                flattenTree(node.right);\n                flattenTree(node.left);\n                node.right = prev;\n                node.left = null;\n                prev = node;\n            };\n            flattenTree(root);\n        };\n        "}, {"questionId": "115", "titleSlug": "distinct-subsequences", "content": "Given two strings s and t, return the number of distinct subsequences of s which equals t. Example 1: Input: s = 'rabbbit', t = 'rabbit' Output: 3. Example 2: Input: s = 'babgbag', t = 'bag' Output: 5. Constraints: 1 <= s.length, t.length <= 1000. s and t consist of English letters.", "typed_code": "\n        var numDistinct = function(s, t) {\n            const dp = Array(t.length + 1).fill(0).map(() => Array(s.length + 1).fill(0));\n            for (let j = 0; j <= s.length; j++) {\n                dp[0][j] = 1;\n            }\n            for (let i = 1; i <= t.length; i++) {\n                for (let j = 1; j <= s.length; j++) {\n                    dp[i][j] = dp[i][j - 1];\n                    if (t[i - 1] === s[j - 1]) {\n                        dp[i][j] += dp[i - 1][j - 1];\n                    }\n                }\n            }\n            return dp[t.length][s.length];\n        };\n        "}]