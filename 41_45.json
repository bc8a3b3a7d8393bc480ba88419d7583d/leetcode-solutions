[{"questionId": "41", "titleSlug": "first-missing-positive", "content": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums. You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.", "typed_code": "function firstMissingPositive(nums) {\n    const n = nums.length;\n    for (let i = 0; i < n; i++) {\n        while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        if (nums[i] !== i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}"}, {"questionId": "42", "titleSlug": "trapping-rain-water", "content": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.", "typed_code": "function trap(height) {\n    let left = 0, right = height.length - 1;\n    let leftMax = 0, rightMax = 0, total = 0;\n    while (left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= leftMax) leftMax = height[left];\n            else total += leftMax - height[left];\n            left++;\n        } else {\n            if (height[right] >= rightMax) rightMax = height[right];\n            else total += rightMax - height[right];\n            right--;\n        }\n    }\n    return total;\n}"}, {"questionId": "43", "titleSlug": "multiply-strings", "content": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.", "typed_code": "function multiply(num1, num2) {\n    let m = num1.length, n = num2.length;\n    let res = Array(m + n).fill(0);\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            let mul = (num1[i] - '0') * (num2[j] - '0');\n            let p1 = i + j, p2 = i + j + 1;\n            let sum = mul + res[p2];\n            res[p1] += Math.floor(sum / 10);\n            res[p2] = sum % 10;\n        }\n    }\n    while (res[0] == 0) res.shift();\n    return res.length ? res.join('') : '0';\n}"}, {"questionId": "44", "titleSlug": "wildcard-matching", "content": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where: '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).", "typed_code": "function isMatch(s, p) {\n    let sIdx = 0, pIdx = 0, match = 0, starIdx = -1;\n    while (sIdx < s.length) {\n        if (pIdx < p.length && (p[pIdx] == '?' || p[pIdx] == s[sIdx])) {\n            sIdx++;\n            pIdx++;\n        } else if (pIdx < p.length && p[pIdx] == '*') {\n            starIdx = pIdx;\n            match = sIdx;\n            pIdx++;\n        } else if (starIdx != -1) {\n            pIdx = starIdx + 1;\n            match++;\n            sIdx = match;\n        } else {\n            return false;\n        }\n    }\n    while (pIdx < p.length && p[pIdx] == '*') pIdx++;\n    return pIdx == p.length;\n}"}, {"questionId": "45", "titleSlug": "jump-game-ii", "content": "You are given a 0-indexed array of integers nums of length n. Each element nums[i] represents the maximum length of a forward jump from index i. Return the minimum number of jumps to reach nums[n - 1].", "typed_code": "function jump(nums) {\n    let jumps = 0, currEnd = 0, currFarthest = 0;\n    for (let i = 0; i < nums.length - 1; i++) {\n        currFarthest = Math.max(currFarthest, i + nums[i]);\n        if (i == currEnd) {\n            jumps++;\n            currEnd = currFarthest;\n        }\n    }\n    return jumps;\n}"}]