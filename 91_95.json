[{"question_id": "91", "title_slug": "decode-ways", "content": "Decoded the message via a mapping of digits to characters, problem is to return the number of ways the message can be decoded.", "typed_code": "\n        function numDecodings(s) {\n            if (s[0] === '0') return 0;\n            let dp = new Array(s.length + 1).fill(0);\n            dp[0] = 1;\n            dp[1] = s[0] === '0' ? 0 : 1;\n            for (let i = 2; i <= s.length; i++) {\n                let oneDigit = parseInt(s.slice(i - 1, i), 10);\n                let twoDigits = parseInt(s.slice(i - 2, i), 10);\n                if (oneDigit >= 1) dp[i] += dp[i - 1];\n                if (twoDigits >= 10 && twoDigits <= 26) dp[i] += dp[i - 2];\n            }\n            return dp[s.length];\n        }\n        "}, {"question_id": "92", "title_slug": "reverse-linked-list-ii", "content": "Reverse nodes of the list from given position left to right, return the reversed list.", "typed_code": "\n        function reverseBetween(head, left, right) {\n            if (!head) return null;\n            let dummy = { next: head };\n            let prev = dummy;\n            for (let i = 1; i < left; i++) prev = prev.next;\n            let curr = prev.next;\n            for (let i = 0; i < right - left; i++) {\n                let next = curr.next;\n                curr.next = next.next;\n                next.next = prev.next;\n                prev.next = next;\n            }\n            return dummy.next;\n        }\n        "}, {"question_id": "93", "title_slug": "restore-ip-addresses", "content": "Return all possible valid IP addresses that can be formed by inserting dots into given string.", "typed_code": "\n        function restoreIpAddresses(s) {\n            const result = [];\n            const dfs = (start, parts) => {\n                if (parts.length === 4 && start === s.length) {\n                    result.push(parts.join('.'));\n                    return;\n                }\n                if (parts.length === 4) return;\n                for (let len = 1; len <= 3; len++) {\n                    if (start + len > s.length) break;\n                    let part = s.slice(start, start + len);\n                    if (part[0] === '0' && part.length > 1) continue;\n                    if (parseInt(part, 10) > 255) continue;\n                    dfs(start + len, [...parts, part]);\n                }\n            };\n            dfs(0, []);\n            return result;\n        }\n        "}, {"question_id": "94", "title_slug": "binary-tree-inorder-traversal", "content": "Return the inorder traversal of nodes' values in the given binary tree.", "typed_code": "\n        function inorderTraversal(root) {\n            let res = [];\n            let stack = [];\n            let curr = root;\n            while (curr !== null || stack.length > 0) {\n                while (curr !== null) {\n                    stack.push(curr);\n                    curr = curr.left;\n                }\n                curr = stack.pop();\n                res.push(curr.val);\n                curr = curr.right;\n            }\n            return res;\n        }\n        "}, {"question_id": "95", "title_slug": "unique-binary-search-trees-ii", "content": "Return all unique binary search trees that can be constructed with given number of nodes.", "typed_code": "\n        function generateTrees(n) {\n            if (n === 0) return [];\n            function buildTrees(start, end) {\n                if (start > end) return [null];\n                let allTrees = [];\n                for (let i = start; i <= end; i++) {\n                    let leftTrees = buildTrees(start, i - 1);\n                    let rightTrees = buildTrees(i + 1, end);\n                    for (let l of leftTrees) {\n                        for (let r of rightTrees) {\n                            let currTree = { val: i, left: l, right: r };\n                            allTrees.push(currTree);\n                        }\n                    }\n                }\n                return allTrees;\n            }\n            return buildTrees(1, n);\n        }\n        "}]