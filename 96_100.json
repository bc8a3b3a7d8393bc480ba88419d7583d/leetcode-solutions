[
    {
        "question_id": "96",
        "title_slug": "unique-binary-search-trees",
        "content": "Given an integer n, return the number of structurally unique BST&#39;s (binary search trees) which has exactly n nodes of unique values from 1 to n.\n\n\n<strong class=\"example\">Example 1:\nhttps://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n\nInput: n = 3\nOutput: 5\n\n\n<strong class=\"example\">Example 2:\n\n\nInput: n = 1\nOutput: 1\n\n\n\nConstraints:\n\n\n\t1 &lt;= n &lt;= 19\n\n",
        "typed_code": "\n    function numTrees(n) {\n        const dp = new Array(n + 1).fill(0);\n        dp[0] = 1;\n        dp[1] = 1;\n\n        for (let i = 2; i <= n; i++) {\n            for (let j = 1; j <= i; j++) {\n                dp[i] += dp[j - 1] + dp[i - j];\n            }\n        }\n\n        return dp[n];\n    }\n    "
    },
    {
        "question_id": "97",
        "title_slug": "interleaving-string",
        "content": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\n\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\n\n\n\ts = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub>\n\tt = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub>\n\t|n - m| &lt;= 1\n\tThe interleaving is s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ... or t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...\n\n\nNote: a + b is the concatenation of strings a and b.\n\n\n<strong class=\"example\">Example 1:\nhttps://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" style=\"width: 561px; height: 203px;\" />\n\nInput: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;\nOutput: true\nExplanation: One way to obtain s3 is:\nSplit s1 into s1 = &quot;aa&quot; + &quot;bc&quot; + &quot;c&quot;, and s2 into s2 = &quot;dbbc&quot; + &quot;a&quot;.\nInterleaving the two splits, we get &quot;aa&quot; + &quot;dbbc&quot; + &quot;bc&quot; + &quot;a&quot; + &quot;c&quot; = &quot;aadbbcbcac&quot;.\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\n\n<strong class=\"example\">Example 2:\n\n\nInput: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;\nOutput: false\nExplanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\n\n<strong class=\"example\">Example 3:\n\n\nInput: s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;\nOutput: true\n\n\n\nConstraints:\n\n\n\t0 &lt;= s1.length, s2.length &lt;= 100\n\t0 &lt;= s3.length &lt;= 200\n\ts1, s2, and s3 consist of lowercase English letters.\n\n\n\nFollow up: Could you solve it using only O(s2.length) additional memory space?\n",
        "typed_code": "\n    function isInterleave(s1, s2, s3) {\n        if (s1.length + s2.length !== s3.length) return false;\n        const dp = Array(s1.length + 1).fill().map(() => Array(s2.length + 1).fill(false));\n        dp[0][0] = true;\n\n        for (let i = 0; i <= s1.length; i++) {\n            for (let j = 0; j <= s2.length; j++) {\n                if (i > 0) dp[i][j] = dp[i][j] || (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]);\n                if (j > 0) dp[i][j] = dp[i][j] || (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n            }\n        }\n\n        return dp[s1.length][s2.length];\n    }\n    "
    },
    {
        "question_id": "98",
        "title_slug": "validate-binary-search-tree",
        "content": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n\n\n\tThe left <span data-keyword=\"subtree\">subtree of a node contains only nodes with keys less than the node&#39;s key.\n\tThe right subtree of a node contains only nodes with keys greater than the node&#39;s key.\n\tBoth the left and right subtrees must also be binary search trees.\n\n\n\n<strong class=\"example\">Example 1:\nhttps://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n\nInput: root = [2,1,3]\nOutput: true\n\n\n<strong class=\"example\">Example 2:\nhttps://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" />\n\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.\n\n\n\nConstraints:\n\n\n\tThe number of nodes in the tree is in the range [1, 10<sup>4</sup>].\n\t-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1\n\n",
        "typed_code": "\n    function isValidBST(root, min = null, max = null) {\n        if (!root) return true;\n        if (min !== null && root.val <= min) return false;\n        if (max !== null && root.val >= max) return false;\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\n    }\n    "
    },
    {
        "question_id": "99",
        "title_slug": "recover-binary-search-tree",
        "content": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\n\n\n<strong class=\"example\">Example 1:\nhttps://assets.leetcode.com/uploads/2020/10/28/recover1.jpg\" style=\"width: 422px; height: 302px;\" />\n\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.\n\n\n<strong class=\"example\">Example 2:\nhttps://assets.leetcode.com/uploads/2020/10/28/recover2.jpg\" style=\"width: 581px; height: 302px;\" />\n\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.\n\n\n\nConstraints:\n\n\n\tThe number of nodes in the tree is in the range [2, 1000].\n\t-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1\n\n\n\nFollow up: A solution using O(n) space is pretty straight-forward. Could you devise a constant O(1) space solution?",
        "typed_code": "\n    function recoverTree(root) {\n        let first = null, second = null, prev = null;\n\n        function inorder(node) {\n            if (!node) return;\n\n            inorder(node.left);\n            if (prev && node.val < prev.val) {\n                if (!first) first = prev;\n                second = node;\n            }\n            prev = node;\n            inorder(node.right);\n        }\n\n        inorder(root);\n        [first.val, second.val] = [second.val, first.val];\n    }\n    "
    },
    {
        "question_id": "100",
        "title_slug": "same-tree",
        "content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n\n<strong class=\"example\">Example 1:\nhttps://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\" style=\"width: 622px; height: 182px;\" />\n\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\n\n<strong class=\"example\">Example 2:\nhttps://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\" style=\"width: 382px; height: 182px;\" />\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\n\n<strong class=\"example\">Example 3:\nhttps://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\" style=\"width: 622px; height: 182px;\" />\n\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\n\n\nConstraints:\n\n\n\tThe number of nodes in both trees is in the range [0, 100].\n\t-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup>\n\n",
        "typed_code": "\n    function isSameTree(p, q) {\n        if (!p && !q) return true;\n        if (!p || !q || p.val !== q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n    "
    }
]